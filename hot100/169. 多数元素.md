### 多数元素



> 给定一个大小为 `n` 的数组 `nums` ，返回其中的多数元素。多数元素是指在数组中出现次数 **大于** `⌊ n/2 ⌋` 的元素。
>
> 你可以假设数组是非空的，并且给定的数组总是存在多数元素。
>
>  
>
> **示例 1：**
>
> ```
> 输入：nums = [3,2,3]
> 输出：3
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [2,2,1,1,1,2,2]
> 输出：2
> ```
>
>  
>
> **提示：**
>
> - `n == nums.length`
> - `1 <= n <= 5 * 104`
> - `-109 <= nums[i] <= 109`
>
>  
>
> **进阶：**尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题。



### code

> **Boyer-Moore 投票算法 (最优解)**
>
> - **核心思想**: 此算法非常巧妙，可以想象成一个“阵地攻防”或“选举投票”的过程。我们维护一个候选人（`candidate`）和他的票数（`count`）。
> - **为什么这么做**: 核心逻辑是**对拼消耗**。因为多数元素的数量比所有其他元素数量的总和还要多，所以即使它每次都和“敌人”（非多数元素）进行一换一的消耗，最后也一定能剩下。
>   1. 从第一个元素开始，假设它就是候选人，票数 `count` 为 1。
>   2. 遍历数组，如果下一个元素和候选人相同，`count` 加 1。
>   3. 如果下一个元素和候选人不同，`count` 减 1。
>   4. 如果 `count` 减到 0，说明之前的候选人“阵亡”了，我们就选举下一个遍历到的元素为**新候选人**。
>   5. 由于多数元素必然超过一半，它最终一定会作为候选人存活下来。
> - **评价**: 时间复杂度仅为 O(N)，空间复杂度为 O(1)。

```c++
#include <vector>

class Solution {
public:
    int majorityElement(std::vector<int>& nums) {
        int candidate = 0;
        int count = 0;

        for (int num : nums) {
            if (count == 0) {
                candidate = num;
            }
            
            if (num == candidate) {
                count++;
            } else {
                count--;
            }
        }
        return candidate;
    }
};
```



