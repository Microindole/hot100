### 只出现一次的数字

> 给你一个 **非空** 整数数组 `nums` ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
>
> 你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。
>
>  
>
> **示例 1 ：**
>
> **输入：**nums = [2,2,1]
>
> **输出：**1
>
> **示例 2 ：**
>
> **输入：**nums = [4,1,2,1,2]
>
> **输出：**4
>
> **示例 3 ：**
>
> **输入：**nums = [1]
>
> **输出：**1
>
>  
>
> **提示：**
>
> - `1 <= nums.length <= 3 * 104`
> - `-3 * 104 <= nums[i] <= 3 * 104`
> - 除了某个元素只出现一次以外，其余每个元素均出现两次。





### code

```C++
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        unordered_map<int,bool> ones;
        int result = 0;
        for(int num : nums){
            result ^= num;
        }
        return result;
    }
};
/*
这里我原本犯了一个错误:，导致多了很多个0: 
		vector<int> res(n+1,0);
        for(int i = 1;i<=n;i++){
            int temp = res[i/2] + (i&1);
            res.push_back(temp);
        }
*/
```



本题的关键是“某个元素只出现一次以外，其余每个元素均出现两次”，这要用C++的位运算的特性。

**位运算 (最优解)**

- **核心思想**: 这道题的完美解法是利用**异或 (XOR)** 运算的特性。异或运算符在 C++ 中是 `^`。
- **异或运算的关键性质**:
  1. 任何数和 0 进行异或运算，结果仍然是原来的数 (`a ^ 0 = a`)。
  2. 任何数和自身进行异О或运算，结果是 0 (`a ^ a = 0`)。
  3. 异或运算满足交换律和结合律 (`a ^ b ^ a = (a ^ a) ^ b = 0 ^ b = b`)。
- **为什么这么做**: 基于以上性质，我们可以得出推论：**将数组中所有的数字进行异或运算，最终的结果就是那个只出现一次的数字。** 因为所有出现两次的元素，在异或运算中都会两两抵消变成0，最后只剩下那个单独的数字与0进行异或，结果就是它本身。
  - 例如，对于数组 `[4, 1, 2, 1, 2]`，计算过程如下： `4 ^ 1 ^ 2 ^ 1 ^ 2` `= 4 ^ (1 ^ 1) ^ (2 ^ 2)` (根据交换律和结合律) `= 4 ^ 0 ^ 0` `= 4`
- 这个方法只遍历一次数组，时间复杂度为 O(N)；并且只用了一个变量来存储异或的累计结果，空间复杂度为 O(1)。**完美符合题目的所有要求**。