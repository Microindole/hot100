### 最大正方形

> 在一个由 `'0'` 和 `'1'` 组成的二维矩阵内，找到只包含 `'1'` 的最大正方形，并返回其面积。
>
>  
>
> **示例 1：**
>
> ![img](https://assets.leetcode.com/uploads/2020/11/26/max1grid.jpg)
>
> ```
> 输入：matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]
> 输出：4
> ```
>
> **示例 2：**
>
> ![img](https://assets.leetcode.com/uploads/2020/11/26/max2grid.jpg)
>
> ```
> 输入：matrix = [["0","1"],["1","0"]]
> 输出：1
> ```
>
> **示例 3：**
>
> ```
> 输入：matrix = [["0"]]
> 输出：0
> ```
>
>  
>
> **提示：**
>
> - `m == matrix.length`
> - `n == matrix[i].length`
> - `1 <= m, n <= 300`
> - `matrix[i][j]` 为 `'0'` 或 `'1'`



### code

```c++
#include <vector>

class Solution {
public:
    int maximalSquare(vector<vector<char>>& matrix) {
        if (matrix.empty() || matrix[0].empty()) {
            return 0;
        }
        int max_size = 0;
        int row = matrix.size();
        int col = matrix[0].size();

        vector<vector<int>> dp(row + 1, vector<int>(col + 1, 0));
        for (int i = 1; i <= row; i++) {
            for (int j = 1; j <= col; j++) {
                if (matrix[i - 1][j - 1] == '1') {
                    dp[i][j] =
                        1 + min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]});
                    max_size = max(max_size, dp[i][j]);
                }
            }
        }

        return max_size * max_size;
    }
};
```



在正方形中的所有子区域也是正方形的，所以从这里要想到使用动态规划的方法。

同时，在这里将正方形退化成一个点考虑：比如某一个位置表示这个位置一点为正方形的右下角，这个可以将所有问题转化为过去的问题的结果

