### 比特位计数

> 给你一个整数 `n` ，对于 `0 <= i <= n` 中的每个 `i` ，计算其二进制表示中 **`1` 的个数** ，返回一个长度为 `n + 1` 的数组 `ans` 作为答案。
>
>  
>
> **示例 1：**
>
> ```
> 输入：n = 2
> 输出：[0,1,1]
> 解释：
> 0 --> 0
> 1 --> 1
> 2 --> 10
> ```
>
> **示例 2：**
>
> ```
> 输入：n = 5
> 输出：[0,1,1,2,1,2]
> 解释：
> 0 --> 0
> 1 --> 1
> 2 --> 10
> 3 --> 11
> 4 --> 100
> 5 --> 101
> ```
>
>  
>
> **提示：**
>
> - `0 <= n <= 105`
>
>  
>
> **进阶：**
>
> - 很容易就能实现时间复杂度为 `O(n log n)` 的解决方案，你可以在线性时间复杂度 `O(n)` 内用一趟扫描解决此问题吗？
> - 你能不使用任何内置函数解决此问题吗？（如，C++ 中的 `__builtin_popcount` ）



### code

```c++
class Solution {
public:
    vector<int> countBits(int n) {
        vector<int> res;
        res.push_back(0);
        for(int i = 1;i<=n;i++){
            int temp = res[i/2] + (i&1);
            res.push_back(temp);
        }
        return res;
    }
};
```

- 这里首先要想到可以按位计算，即for循环每一个数字后对每个数字进行无符号的右移。每次与1进行与运算后加入计数器。

  [位运算](../knowledge/位运算.md)

- 但是这样无法满足进阶要求，所以这样采用动态规划的方法解决问题。即上面的代码。

  首先要找到了这个的递推关系（状态转移方程）：

  ​			`ans[i]=ans[i≫1]+(i & 1)`

  利用这个公式，在一次遍历中，从 `ans[0]` 逐步递推出 `ans[n]`

  动态规划详见：[动态规划思考](../knowledge/动态规划思考.md)

