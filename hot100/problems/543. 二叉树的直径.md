### 二叉树的直径



> 给你一棵二叉树的根节点，返回该树的 **直径** 。
>
> 二叉树的 **直径** 是指树中任意两个节点之间最长路径的 **长度** 。这条路径可能经过也可能不经过根节点 `root` 。
>
> 两节点之间路径的 **长度** 由它们之间边数表示。
>
>  
>
> **示例 1：**
>
> ![img](https://assets.leetcode.com/uploads/2021/03/06/diamtree.jpg)
>
> ```powershell
> 输入：root = [1,2,3,4,5]
> 输出：3
> 解释：3 ，取路径 [4,2,1,3] 或 [5,2,1,3] 的长度。
> ```
>
> **示例 2：**
>
> ```powershell
> 输入：root = [1,2]
> 输出：1
> ```
>
>  
>
> **提示：**
>
> - 树中节点数目在范围 `[1, 104]` 内
> - `-100 <= Node.val <= 100`



### code

```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),
 * right(right) {}
 * };
 */
class Solution {
public:
    int diameter = 0;

    int currentHeight(TreeNode* curr) {
        if (curr == nullptr)
            return 0;

        int left_height = currentHeight(curr->left);
        int right_height = currentHeight(curr->right);
        diameter = max(diameter, left_height + right_height);
        return max(left_height, right_height) + 1;
    }

    int diameterOfBinaryTree(TreeNode* root) {
        diameter = 0;
        currentHeight(root);
        return diameter;
    }
};
```

首先，关于任何二叉树的问题首先要想到二叉树的三种遍历。其次二叉树的问题能用递归求解一般来说更加简单。

- 求一棵树最大的长度首先要有一个变量来存储这个最大长度。

- 接着，递归地求解要关注它本身，左子树，右子树以及和最大值相比较（相比较是为了区分直径是来源是否横跨某一节点的两棵子树）。

- 最后，根据二叉树递归的通用结构：

  > 1. 终止条件
  > 2. 递归形式
  > 3. 处理递归数据
  > 4. 返回形式

  得到答案.