位运算是直接在整数的二进制表示上进行的操作。它速度极快，因为这是 CPU 设计时就原生支持的运算。理解位运算对于编写高性能代码、处理底层数据、实现算法（如加密、压缩）、以及在嵌入式系统编程中都至关重要。

C++ 提供了以下 6 种位运算符：

1. **按位与 (AND)**: `&`
2. **按位或 (OR)**: `|`
3. **按位异或 (XOR)**: `^`
4. **按位取反 (NOT)**: `~`
5. **左移 (Left Shift)**: `<<`
6. **右移 (Right Shift)**: `>>`

------



### 基本概念：二进制位



在进行位运算之前，必须理解所有整数在计算机内部都是以二进制形式存储的。例如，对于一个 8 位的无符号整数 (`unsigned char`)：

- 十进制的 `10` 是 `00001010`
- 十进制的 `12` 是 `00001100`

下面的讲解将主要使用 8 位二进制数作为示例。

------



### 1. 按位与 (AND: `&`)



**规则**: 只有当两个操作数的对应位都为 `1` 时，结果的该位才为 `1`，否则为 `0`。

| A    | B    | A & B |
| ---- | ---- | ----- |
| 0    | 0    | 0     |
| 0    | 1    | 0     |
| 1    | 0    | 0     |
| 1    | 1    | 1     |

**示例**: `10 & 12`

```c++
  00001010  (十进制 10)
& 00001100  (十进制 12)
------------------
  00001000  (十进制 8)
```

所以，`10 & 12` 的结果是 `8`。

**常见用途**:

- **判断奇偶性**: `(x & 1) == 0` 为偶，`(x & 1) == 1` 为奇。因为任何偶数的二进制末位是 0，奇数是 1。

- **清零特定位 (Bit Masking)**: 将一个数与一个特定“掩码”进行`&`运算，可以只保留想要的位。例如，要保留一个数的低 4 位，可以 `x & 0b1111`（即 `x & 15`）。

  C++

  ```c++
  int a = 173;      // 二进制: 10101101
  int mask = 15;      // 二进制: 00001111
  int result = a & mask; // 结果: 00001101 (十进制 13)
  ```

------



### 2. 按位或 (OR: `|`)



**规则**: 当两个操作数的对应位中至少有一个为 `1` 时，结果的该位就为 `1`，否则为 `0`。

| A | B | A \| B |
|---|---|-------|
| 0 | 0 |    0   |
| 0 | 1 |    1   |
| 1 | 0 |    1   |
| 1 | 1 |    1   |

**示例**: `10 | 12`

```c++
  00001010  (十进制 10)
| 00001100  (十进制 12)
------------------
  00001110  (十进制 14)
```

所以，`10 | 12` 的结果是 `14`。

**常见用途**:

- **设置特定位 (置为 1)**: 将一个数与一个特定掩码进行`|`运算，可以将掩码中为 `1` 的位设置为 `1`，而不影响其他位。

  C++

  ```c++
  // 将变量 flags 的第 3 位（从右数，从 0 开始）设置为 1
  unsigned char flags = 0b10110101;
  unsigned char mask = 0b00001000; // 第 3 位是 1
  flags = flags | mask;           // 结果: 0b10111101
  ```

------



### 3. 按位异或 (XOR: `^`)



**规则**: 当两个操作数的对应位不相同时，结果的该位为 `1`，相同时为 `0`。可以理解为“无进位的二进制加法”。

| A    | B    | A ^ B |
| ---- | ---- | ----- |
| 0    | 0    | 0     |
| 0    | 1    | 1     |
| 1    | 0    | 1     |
| 1    | 1    | 0     |

**示例**: `10 ^ 12`

```c++
  00001010  (十进制 10)
^ 00001100  (十进制 12)
------------------
  00000110  (十进制 6)
```

所以，`10 ^ 12` 的结果是 `6`。

**重要特性与用途**:

- **翻转特定位**: 将一个数与一个掩码进行`^`运算，可以翻转掩码中为 `1` 的那些位。

  C++

  ```c++
  // 翻转 flags 的第 4 位和第 5 位
  unsigned char flags = 0b10110101;
  unsigned char mask = 0b00110000;
  flags = flags ^ mask; // 结果: 0b10000101
  ```

- **自反性**: `A ^ A = 0`。一个数和它自己异或，结果为 0。

- **交换律**: `A ^ B = B ^ A`。

- **结合律**: `(A ^ B) ^ C = A ^ (B ^ C)`。

- **归零律**: `A ^ 0 = A`。

- **应用：不使用临时变量交换两个数**:

  C++

  ```c++
  int a = 10, b = 12;
  a = a ^ b; // a 现在是 10^12
  b = a ^ b; // b 现在是 (10^12)^12 = 10
  a = a ^ b; // a 现在是 (10^12)^10 = 12
  ```

- **应用：查找只出现一次的数字**: 在一个数组中，除一个数字外，其他所有数字都出现两次，可以使用异或找到这个唯一的数字。因为成对的数字异或后都为 0。

------



### 4. 按位取反 (NOT: `~`)



**规则**: 这是一个一元运算符，它将操作数的每一位都进行翻转（`0` 变 `1`，`1` 变 `0`）。

**示例**: `~10`

```c++
~ 00001010  (十进制 10)
------------------
  11110101
```

结果 `11110101` 的十进制值取决于数据类型。

- 如果是 `unsigned char`，它是 `245`。
- 如果是 `signed char`，这是一个负数。计算机用**补码**表示负数。`11110101` 是 `-11` 的补码表示。计算方式为：`-(~x + 1) = -(245 + 1)` (溢出) 或者直接 `~x = -x - 1`，所以 `~10 = -11`。

**常见用途**:

- **生成掩码**: 例如，要清除一个数的低 4 位，可以将 `0b1111` 取反得到 `...11110000`，再与原数进行 `&` 运算。

  C++

  ```c++
  int a = 173;           // 10101101
  int mask = ~0b1111;    // ...11110000
  int result = a & mask; // 10100000 (十进制 160)
  ```

------



### 5. 左移 (Left Shift: `<<`)



**规则**: 将操作数的所有位向左移动指定的位数。右边空出的位用 `0` 填充，左边移出的位被丢弃。

**示例**: `10 << 2`

```c++
  00001010  (十进制 10)
<< 2
------------------
  00101000  (十进制 40)
```

数学意义: 在不发生溢出的情况下，左移 n 位等效于乘以 2n。

10 << 2 等于 10 * 2^2 = 10 * 4 = 40。

**常见用途**:

- **快速乘以 2 的幂**: `x * 8` 可以写成 `x << 3`，效率更高。

- **创建位掩码**: `1 << n` 可以创建一个只有第 `n` 位是 `1` 的掩码。

  C++

  ```c++
  // 创建一个第 5 位为 1 的掩码
  const int MASK_FIFTH_BIT = 1 << 5; // 00100000
  ```

------



### 6. 右移 (Right Shift: `>>`)



**规则**: 将操作数的所有位向右移动指定的位数。左边空出的位如何填充取决于操作数的类型。

**示例**: `40 >> 2`

```c++
  00101000  (十进制 40)
>> 2
------------------
  00001010  (十进制 10)
```

数学意义: 右移 n 位等效于除以 2n（对于正数，结果向下取整）。

40 >> 2 等于 40 / 2^2 = 40 / 4 = 10。

**重要区别：算术右移 vs 逻辑右移**

- **逻辑右移 (Logical Shift)**: 左边空出的位总是用 `0` 填充。这通常用于**无符号整数 (`unsigned`)**。
- **算术右移 (Arithmetic Shift)**: 左边空出的位用**符号位**填充。如果原数是正数（符号位为0），则填充 `0`；如果原数是负数（符号位为1），则填充 `1`。这能保持负数的符号。C++ 标准规定，对于**有符号整数 (`signed`)**，右移的行为是**实现定义的 (implementation-defined)**，但绝大多数现代编译器都采用算术右移。

**示例 (有符号数)**:

```c++
// 假设是 8 位 signed char
signed char a = -40; // 补码: 11011000
signed char result = a >> 2;
// 算术右移，用符号位 1 填充
// 11110110 (这是 -10 的补码)
```

**常见用途**:

- **快速除以 2 的幂**: `x / 16` 可以写成 `x >> 4`。
- **获取特定位的值**: 要检查第 `n` 位是否为 `1`，可以 `(x >> n) & 1`。

------



### 复合赋值运算符



和算术运算符一样，位运算符也有复合赋值形式：

&=, |=, ^=, <<=, >>=

例如 `x = x | MASK;` 可以简写为 `x |= MASK;`。



### 综合示例：位操作实战



假设我们用一个 `unsigned char` (8位) 来表示一个游戏角色的状态。

- 第 0 位: 是否中毒 (isPoisoned)
- 第 1 位: 是否燃烧 (isBurning)
- 第 2 位: 是否冰冻 (isFrozen)
- 第 3 位: 是否隐身 (isInvisible)

C++

```c++
#include <iostream>
#include <bitset> // 用于方便地打印二进制

int main() {
    const unsigned char MASK_POISONED = 1 << 0;  // 00000001
    const unsigned char MASK_BURNING = 1 << 1;   // 00000010
    const unsigned char MASK_FROZEN = 1 << 2;    // 00000100
    const unsigned char MASK_INVISIBLE = 1 << 3; // 00001000

    unsigned char status = 0; // 初始状态，什么都没有
    std::cout << "Initial Status: " << std::bitset<8>(status) << std::endl;

    // 1. 设置状态：角色中毒了并且进入隐身
    status |= MASK_POISONED;
    status |= MASK_INVISIBLE;
    std::cout << "Poisoned & Invisible: " << std::bitset<8>(status) << std::endl;

    // 2. 检查状态：角色是否中毒？
    if ((status & MASK_POISONED) != 0) {
        std::cout << "Character is poisoned." << std::endl;
    }

    // 3. 清除状态：角色被治愈，中毒效果消失
    status &= ~MASK_POISONED;
    std::cout << "Cured from poison: " << std::bitset<8>(status) << std::endl;

    // 4. 翻转状态：角色使用了闪光弹，从隐身变为可见
    status ^= MASK_INVISIBLE;
    std::cout << "Revealed from invisibility: " << std::bitset<8>(status) << std::endl;

    // 5. 复合状态检查：是否同时燃烧且冰冻？ (这不可能，但可以检查)
    const unsigned char MASK_BURN_FROZEN = MASK_BURNING | MASK_FROZEN;
    if ((status & MASK_BURN_FROZEN) == MASK_BURN_FROZEN) {
        std::cout << "Character is both burning and frozen." << std::endl;
    }

    return 0;
}
```

