### 对称二叉树

> 给你一个二叉树的根节点 `root` ， 检查它是否轴对称。
>
>  
>
> **示例 1：**
>
> ![img](https://pic.leetcode.cn/1698026966-JDYPDU-image.png)
>
> ```
> 输入：root = [1,2,2,3,4,4,3]
> 输出：true
> ```
>
> **示例 2：**
>
> ![img](https://pic.leetcode.cn/1698027008-nPFLbM-image.png)
>
> ```
> 输入：root = [1,2,2,null,3,null,3]
> 输出：false
> ```
>
>  
>
> **提示：**
>
> - 树中节点数目在范围 `[1, 1000]` 内
> - `-100 <= Node.val <= 100`
>
>  
>
> **进阶：**你可以运用递归和迭代两种方法解决这个问题吗？

### code

- 数据结构

```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),
 * right(right) {}
 * };
 */
```

- 递归法

```C++
class Solution {
public:
    bool isMirror(TreeNode* left, TreeNode* right) {
        if (left == nullptr && right == nullptr)
            return true;
        if (left == nullptr || right == nullptr || left->val != right->val)
            return false;
        return isMirror(left->right, right->left) &&
               isMirror(left->left, right->right);
    }

    bool isSymmetric(TreeNode* root) {
        if (root == nullptr)
            return true;
        return isMirror(root->left, root->right);
    }
};
```

- 迭代法

```C++
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if (root == nullptr) {
            return true;
        }

        // 使用队列来进行迭代
        std::queue<TreeNode*> q;

        // 1. 将根节点的左右孩子作为第一对比较节点入队
        q.push(root->left);
        q.push(root->right);

        while (!q.empty()) {
            // 2. 每次从队列中取出两个节点进行比较
            TreeNode* leftNode = q.front();
            q.pop();
            TreeNode* rightNode = q.front();
            q.pop();

            // 3. 检查这对节点
            // a. 如果两个都为空，说明这对是镜像的，继续下一对
            if (leftNode == nullptr && rightNode == nullptr) {
                continue;
            }
            // b. 如果只有一个为空，或两个节点值不同，则非镜像
            if (leftNode == nullptr || rightNode == nullptr || leftNode->val != rightNode->val) {
                return false;
            }

            // 4. 按镜像顺序将子节点入队
            //    比较 外侧：左节点的左孩子 vs 右节点的右孩子
            q.push(leftNode->left);
            q.push(rightNode->right);
            //    比较 内侧：左节点的右孩子 vs 右节点的左孩子
            q.push(leftNode->right);
            q.push(rightNode->left);
        }

        // 5. 如果队列为空，且中途没有返回 false，说明整棵树都是对称的
        return true;
    }
};
```

迭代法这里可以想象成从外出到内层一层层的剥开，一层层的比较。

- 注意：C++的Queue中pop()不能返回值

  ```C++
  // ----------------- 正确 ------------------------------
  TreeNode* leftNode = q.front(); // 第1步：查看并获取队首元素
  q.pop();                        // 第2步：将队首元素移除
  
  // ----------------- 错误 ------------------------------
  TreeNode* leftNode = q.pop();
  ```