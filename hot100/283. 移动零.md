### 移动零



>  给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。
>
> **请注意** ，必须在不复制数组的情况下原地对数组进行操作。
>
>  
>
> **示例 1:**
>
> ```
> 输入: nums = [0,1,0,3,12]
> 输出: [1,3,12,0,0]
> ```
>
> **示例 2:**
>
> ```
> 输入: nums = [0]
> 输出: [0]
> ```
>
>  
>
> **提示**:
>
> - `1 <= nums.length <= 104`
> - `-231 <= nums[i] <= 231 - 1`
>
>  
>
> **进阶：**你能尽量减少完成的操作次数吗？



### code

```C++
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int size = nums.size();
        queue<int> q;
        for (int num : nums) {
            if (num)
                q.push(num);
        }
        int index = 0;
        while (!q.empty()) {
            nums[index] = q.front();
            index++;
            q.pop();
        }
        while (index < size) {
            nums[index] = 0;
            index++;
        }
    }
};
```

以上是用队列的解法，这个应该一下就能想出来。

但是，这个方法可能不满足“**请注意**”中的要求，更不满足 **进阶** 要求。*LeetCode 击败100%怎么回事？*

---

这里推荐使用双指针法：

- 队列法并不是真正的“原地”修改的方法，而且很可能不符合复制数组的要求

- 双指针法的关键在于如何把非零的元素“压缩”到最前面

  > **核心思想**: 使用一个指针 `insert_pos` (或叫 `slow` 指针) 来记录**下一个非零元素应该被放置的位置**。然后用另一个指针（或直接用 `for` 循环的索引 `i`）来遍历整个数组。

```C++
#include <vector>

class Solution {
public:
    void moveZeroes(std::vector<int>& nums) {
        // insert_pos 指向下一个非零元素应该被放置的位置
        int insert_pos = 0;
        
        // 第一次遍历：将所有非零元素移动到数组前面
        for (int i = 0; i < nums.size(); ++i) {
            if (nums[i] != 0) {
                // 将非零元素放到 insert_pos 位置
                nums[insert_pos] = nums[i];
                // 如果 i 和 insert_pos 不在同一个位置，
                // 并且原来的 insert_pos 位置不是 0，
                // 那么原来的 nums[insert_pos] 需要被覆盖
                // 但这里我们不用担心，因为原来的 nums[insert_pos] 要么是0，要么就是 nums[i] 自己
                insert_pos++;
            }
        }
        
        // 第二次遍历：将 insert_pos 之后的所有元素设置为 0
        for (int i = insert_pos; i < nums.size(); ++i) {
            nums[i] = 0;
        }
    }
};

// 交换元素的版本，代码更简洁
class SolutionOptimized {
public:
    void moveZeroes(std::vector<int>& nums) {
        int insert_pos = 0;
        for (int i = 0; i < nums.size(); ++i) {
            if (nums[i] != 0) {
                std::swap(nums[insert_pos], nums[i]);
                insert_pos++;
            }
        }
    }
};
```

- 注意：这里微小的更多写操作和使用swap之间的开销差距忽略不计