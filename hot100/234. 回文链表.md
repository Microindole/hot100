### 回文链表



> 给你一个单链表的头节点 `head` ，请你判断该链表是否为回文链表。如果是，返回 `true` ；否则，返回 `false` 。
>
>  
>
> **示例 1：**
>
> ![img](https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg)
>
> ```
> 输入：head = [1,2,2,1]
> 输出：true
> ```
>
> **示例 2：**
>
> ![img](https://assets.leetcode.com/uploads/2021/03/03/pal2linked-list.jpg)
>
> ```
> 输入：head = [1,2]
> 输出：false
> ```
>
>  
>
> **提示：**
>
> - 链表中节点数目在范围`[1, 105]` 内
> - `0 <= Node.val <= 9`



### code

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
private:
    ListNode* reverseList(ListNode* head){
        ListNode* prev = nullptr;
        ListNode* curr = head;
        while(curr != nullptr){
            ListNode* nextTemp = curr -> next;
            curr -> next = prev;
            prev = curr;
            curr = nextTemp;
        }
        return prev;
    }
public:
    bool isPalindrome(ListNode* head) {
        if(head == nullptr || head -> next == nullptr) return true;
        ListNode* slow = head;
        ListNode* fast = head;
        while (fast -> next != nullptr && fast -> next -> next != nullptr){
            slow = slow -> next;
            fast = fast -> next -> next;
        }
        ListNode* p1 = head;
        ListNode* p2 = reverseList(slow -> next);
        bool is_palindrome = true;
        ListNode* second_half_head = p2;
        while (p2 != nullptr){
            if (p1 -> val != p2 -> val) {
                is_palindrome = false;
                break;
            }
            p1 = p1 -> next;
            p2 = p2 -> next;
        }
        slow->next = reverseList(second_half_head);
        return is_palindrome;
    }
};
```





这里使用快慢节点的方法，注意`is_palindrome = false;`最好不要改成`return false`，这样会省略恢复原链表结构的过程。