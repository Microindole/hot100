### 1. 什么是单调栈？



单调栈是一种特殊的栈，它在整个操作过程中，**栈内的元素始终保持单调性**（单调递增或单调递减）。

- **单调递增栈**：从栈底到栈顶的元素是严格递增的。`stack[bottom] < stack[1] < ... < stack[top]`。
- **单调递减栈**：从栈底到栈顶的元素是严格递减的。`stack[bottom] > stack[1] > ... < stack[top]`。

这个单调性是通过在入栈（`push`）时进行特殊操作来维持的。如果一个新元素要入栈，但它的加入会破坏栈的单调性，那么就需要先将栈顶不符合单调性的元素弹出，直到新元素可以满足单调性为止，然后再将新元素入栈。

------



### 2. 为什么用单调栈？（什么情况使用？）



单调栈的核心用途是，在一个序列中，为每一个元素**寻找其左边或右边第一个比它大（或小）的元素**。

这类问题如果用暴力法解决，通常需要两层循环，时间复杂度为 O(N2)。而使用单调栈，可以将时间复杂度优化到 **O(N)**，因为每个元素最多只会入栈一次、出栈一次。

---

**核心应用场景（识别题目的关键）**： 当你需要解决“下一个更大/更小元素”（Next Greater/Smaller Element）或“上一个更大/更小元素”（Previous Greater/Smaller Element）这类问题时，就应该立刻想到单调栈。

---

**具体问题模式**：

- 对于数组中的每个元素，找出它右边第一个比它大的数。
- 对于数组中的每个元素，找出它左边第一个比它小的数。
- 计算数组中每个元素能作为最小值的最大区间范围。（经典应用：[84. 柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/)）

### 3. 具体怎么使用？



我们以“寻找每个元素右边第一个更大的元素”为例，来讲解其通用模板。这需要一个**单调递减栈**。

**算法流程**：

1. 初始化一个空栈 `s` 和一个结果数组 `result`。
2. 从左到右遍历原数组的每一个元素 `current_element`。
3. 对于当前元素，进入一个 `while` 循环：
   - **循环条件**：栈不为空 `&&` 当前元素 `current_element` **大于** 栈顶元素 `s.top()`。
   - **循环体**：
     - 这说明，对于栈顶元素 `s.top()` 而言，我们已经找到了它右边第一个比它大的元素，就是 `current_element`。
     - 处理这个结果（比如记录在 `result` 数组中）。
     - 将栈顶元素弹出 `s.pop()`。
   - 这个 `while` 循环会一直持续，直到栈为空或者当前元素不再大于栈顶元素（即单调性得以维持）。
4. `while` 循环结束后，将当前元素 `current_element` 入栈 `s.push(current_element)`。
5. 遍历结束后，栈中剩余的元素意味着它们在右边没有找到比自己更大的元素。

------



### 4. 代码讲解 (`dailyTemperatures`)



 LeetCode 上的经典题目 [739. 每日温度](https://leetcode.cn/problems/daily-temperatures/)。

**问题**：给定一个每日温度的数组 `temperatures`，请计算并返回一个数组，其中每个元素表示为了等到一个更暖和的日子，需要等待多少天。如果之后没有更暖和的日子，则用 `0` 表示。

**分析**：这个问题本质上就是为每个温度值，**寻找它右边第一个比它大的值，并计算它们之间的索引差**。这完全符合单调栈的应用场景。

我们需要一个**单调递减栈**来解决这个问题。为什么是递减的？因为我们把“冷”的日子（温度低的）压在“热”的日子（温度高的）上面。当遇到一个更热的日子时，就能轻松地把栈顶那些“冷”的日子都处理掉。

**代码逐行讲解**：

```c++
#include <vector>
#include <stack>

using namespace std;

class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        int n = temperatures.size();
        // 1. 初始化结果数组，默认值为 0，正好满足“如果没有更暖和的日子”的条件
        vector<int> result(n, 0); 
        
        // 2. 声明一个栈。关键点：栈里存放的是数组的【索引】，而不是温度值。
        // 存放索引才能计算天数差。
        stack<int> temperatures_stack; 

        // 3. 从左到右遍历每一天的温度
        for (int i = 0; i < n; i++) {

            // 4. while 循环是单调栈的核心
            //    条件1: 栈不为空
            //    条件2: 当前遍历到的温度(temperatures[i]) > 栈顶索引对应的温度                          
                        // (temperatures[temperatures_sta ck.top()])
            //    这个条件意味着，对于栈顶的那一天，我们找到了一个更暖和的日子(第 i 天)
            while (!temperatures_stack.empty() &&
                   temperatures[i] > temperatures[temperatures_stack.top()]) {
                
                // 5. 获取栈顶的索引，这个索引对应的就是那个“等待更暖和日子”的过去某一天
                int curr_index = temperatures_stack.top();
                
                // 6. 计算天数差 (当前天索引 - 过去天索引) 并存入结果数组
                result[curr_index] = i - curr_index;
                
                // 7. 栈顶这一天已经找到了答案，将其弹出
                temperatures_stack.pop();
            }
            
            // 8. 当前天的索引入栈，等待未来找到比它更暖和的日子
            //    由于 while 循环已经把所有比 temperatures[i] 小的都弹出了，
            //    所以此时入栈，能够维持栈的单调递减性 (就温度而言)
            temperatures_stack.push(i);
        }
        
        // 9. 遍历结束后，栈里可能还剩下一些索引，
        //    这些索引对应的日子在后面没有找到更暖和的，但 result 数组初始值就是 0，所以无需额外处理。
        return result;
    }
};
```



**举例走一遍流程：`temperatures = [73, 74, 75, 71, 69, 72, 76, 73]`**



| `i`  | `temperatures[i]` | 栈 `temperatures_stack` (存索引) | 操作                                                         | `result` 数组              |
| ---- | ----------------- | -------------------------------- | ------------------------------------------------------------ | -------------------------- |
| 0    | 73                | `[0]`                            | `73` 入栈                                                    | `[0, 0, 0, 0, 0, 0, 0, 0]` |
| 1    | 74                | `[1]`                            | `74 > 73`，弹出`0`。`result[0]=1-0=1`。`74`入栈              | `[1, 0, 0, 0, 0, 0, 0, 0]` |
| 2    | 75                | `[2]`                            | `75 > 74`，弹出`1`。`result[1]=2-1=1`。`75`入栈              | `[1, 1, 0, 0, 0, 0, 0, 0]` |
| 3    | 71                | `[2, 3]`                         | `71 < 75`，`71`直接入栈                                      | `[1, 1, 0, 0, 0, 0, 0, 0]` |
| 4    | 69                | `[2, 3, 4]`                      | `69 < 71`，`69`直接入栈                                      | `[1, 1, 0, 0, 0, 0, 0, 0]` |
| 5    | 72                | `[2, 5]`                         | `72 > 69`，弹`4`，`res[4]=5-4=1`。`72 > 71`，弹`3`，`res[3]=5-3=2`。`72`入栈 | `[1, 1, 0, 2, 1, 0, 0, 0]` |
| 6    | 76                | `[6]`                            | `76 > 72`，弹`5`，`res[5]=6-5=1`。`76 > 75`，弹`2`，`res[2]=6-2=4`。`76`入栈 | `[1, 1, 4, 2, 1, 1, 0, 0]` |
| 7    | 73                | `[6, 7]`                         | `73 < 76`，`73`直接入栈                                      | `[1, 1, 4, 2, 1, 1, 0, 0]` |

遍历结束，栈中 [6, 7] 对应的日子没有更暖和的，result 中对应位置是初始值 0，正确。

最终返回 [1, 1, 4, 2, 1, 1, 0, 0]。