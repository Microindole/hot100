## 一、 二叉树的核心地位与考察点

二叉树之所以在面试中如此重要，是因为它几乎是所有复杂数据结构（如红黑树、B树、堆、哈希表内部结构等）的基础，并且能完美地考察以下几个方面的能力：

1.  **递归思想**：二叉树的定义本身就是递归的（一个节点和它的左、右子树），因此绝大多数二叉树问题都可以用递归优雅地解决。这能直接考察你是否能将一个大问题分解为性质相同的子问题。
2.  **非递归（迭代）实现**：将递归算法转换为迭代算法，需要借助栈（模拟递归调用栈）或队列。这能考察你对数据结构的深入理解和手动控制程序流程的能力，也能避免递归深度过大导致的栈溢出问题。
3.  **逻辑思维的严谨性**：处理边界条件（如空树、单个节点的树）、节点关系（父、子、兄弟）以及遍历过程中的状态维护，都需要非常清晰和严谨的逻辑。
4.  **算法的组合与应用**：很多问题不是单一的遍历，而是将遍历与回溯、分治、动态规划等思想结合起来。

-----

## 二、 基础中的基础：节点定义与四种遍历

在开始一切之前，必须先掌握二叉树的节点定义和四种核心遍历方式。它们是你解决几乎所有二叉树问题的“内功心法”。

### 1\. 节点定义 (C++)

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <stack>
#include <algorithm>
#include <unordered_map>

// C++ 中二叉树节点的标准定义
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};
```

### 2\. 四种核心遍历

遍历是访问树中每个节点一次且仅一次的过程。不同的遍历顺序会产生不同的节点序列，适用于解决不同类型的问题。

#### a. 前序遍历 (Pre-order Traversal): 根 -\> 左 -\> 右

  * **思路**：常用于需要“自顶向下”处理问题的场景，比如创建树的副本、序列化树。
  * **递归实现**：最自然，代码最简洁。

<!-- end list -->

```cpp
void preorderTraversal(TreeNode* root) {
    if (root == nullptr) {
        return;
    }
    std::cout << root->val << " "; // 处理根节点
    preorderTraversal(root->left);  // 递归左子树
    preorderTraversal(root->right); // 递归右子树
}
```

  * **迭代实现**：使用栈来模拟递归过程。

<!-- end list -->

```cpp
void preorderTraversalIterative(TreeNode* root) {
    if (root == nullptr) return;
    std::stack<TreeNode*> s;
    s.push(root);
    while (!s.empty()) {
        TreeNode* node = s.top();
        s.pop();
        std::cout << node->val << " "; // 处理根节点
        // 注意：先压入右子节点，再压入左子节点，保证出栈时是先左后右
        if (node->right) {
            s.push(node->right);
        }
        if (node->left) {
            s.push(node->left);
        }
    }
}
```

#### b. 中序遍历 (In-order Traversal): 左 -\> 根 -\> 右

  * **思路**：对于**二叉搜索树 (BST)**，中序遍历会得到一个有序的升序序列。这是BST最重要的性质，也是大量相关问题的解题关键。
  * **递归实现**：

<!-- end list -->

```cpp
void inorderTraversal(TreeNode* root) {
    if (root == nullptr) {
        return;
    }
    inorderTraversal(root->left);   // 递归左子树
    std::cout << root->val << " ";  // 处理根节点
    inorderTraversal(root->right);  // 递归右子树
}
```

  * **迭代实现**：稍微复杂，需要一个指针`curr`来遍历，用栈来存储“回头路”。

<!-- end list -->

```cpp
void inorderTraversalIterative(TreeNode* root) {
    std::stack<TreeNode*> s;
    TreeNode* curr = root;
    while (curr != nullptr || !s.empty()) {
        while (curr != nullptr) {
            s.push(curr);
            curr = curr->left; // 一直向左走到底
        }
        curr = s.top();
        s.pop();
        std::cout << curr->val << " "; // 弹出并处理
        curr = curr->right; // 转向右子树
    }
}
```

#### c. 后序遍历 (Post-order Traversal): 左 -\> 右 -\> 根

  * **思路**：常用于需要“自底向上”处理问题的场景。因为要处理一个节点，必须先处理完它的左右子树。典型应用：计算树的高度/深度、判断平衡二叉树、释放/销毁树的内存。
  * **递归实现**：

<!-- end list -->

```cpp
void postorderTraversal(TreeNode* root) {
    if (root == nullptr) {
        return;
    }
    postorderTraversal(root->left);  // 递归左子树
    postorderTraversal(root->right); // 递归右子树
    std::cout << root->val << " ";   // 处理根节点
}
```

  * **迭代实现**：可以看作是前序遍历（根-\>右-\>左）的逆序。

<!-- end list -->

```cpp
void postorderTraversalIterative(TreeNode* root) {
    if (root == nullptr) return;
    std::stack<TreeNode*> s;
    std::vector<int> result;
    s.push(root);
    while(!s.empty()){
        TreeNode* node = s.top();
        s.pop();
        result.push_back(node->val);
        if(node->left) s.push(node->left); // 先左后右
        if(node->right) s.push(node->right);
    }
    std::reverse(result.begin(), result.end()); // 反转结果
    for(int val : result) {
        std::cout << val << " ";
    }
}
```

#### d. 层序遍历 (Level-order Traversal): 按层从上到下，从左到右

  * **思路**：常用于广度优先搜索 (BFS) 相关问题，如查找最短路径、按层打印、找到最底层最左边的节点等。
  * **实现**：必须使用队列。

<!-- end list -->

```cpp
void levelOrderTraversal(TreeNode* root) {
    if (root == nullptr) return;
    std::queue<TreeNode*> q;
    q.push(root);
    while (!q.empty()) {
        TreeNode* node = q.front();
        q.pop();
        std::cout << node->val << " ";
        if (node->left) {
            q.push(node->left);
        }
        if (node->right) {
            q.push(node->right);
        }
    }
}
```

-----

## 三、 常见问题分类、解题思路与代码示例

面试和机试中的二叉树问题，万变不离其宗，大都可以归为以下几类。

### 类别一：树的属性计算

这类问题通常需要遍历整棵树，并利用子问题的解来计算当前问题的解。后序遍历（或深度优先搜索 DFS）是解决这类问题的利器。

#### 1\. 计算树的最大深度

  * **思路**：一棵树的最大深度等于其左、右子树深度的较大值 + 1。这是典型的分治思想，也是后序遍历的应用。
  * **代码示例**：

<!-- end list -->

```cpp
int maxDepth(TreeNode* root) {
    // 基线条件 (Base Case)
    if (root == nullptr) {
        return 0;
    }
    // 递归计算左右子树的深度
    int left_depth = maxDepth(root->left);
    int right_depth = maxDepth(root->right);
    // 后序位置：利用子问题的结果计算当前节点的结果
    return std::max(left_depth, right_depth) + 1;
}
```

#### 2\. 判断是否是平衡二叉树

  * **思路**：一棵树是平衡的，当且仅当：(1) 它的左子树是平衡的；(2) 它的右子树是平衡的；(3) 左右子树的高度差不超过1。这依然是“自底向上”的判断，适合后序遍历。我们可以让递归函数返回高度，如果发现不平衡，就返回一个特殊值（如-1）。
  * **代码示例**：

<!-- end list -->

```cpp
// 返回树的高度，如果不是平衡树则返回-1
int getHeightAndCheckBalance(TreeNode* root) {
    if (root == nullptr) {
        return 0;
    }
    int left_height = getHeightAndCheckBalance(root->left);
    if (left_height == -1) return -1;

    int right_height = getHeightAndCheckBalance(root->right);
    if (right_height == -1) return -1;
    
    if (std::abs(left_height - right_height) > 1) {
        return -1;
    }
    
    return std::max(left_height, right_height) + 1;
}

bool isBalanced(TreeNode* root) {
    return getHeightAndCheckBalance(root) != -1;
}
```

#### 3\. 计算二叉树的直径

  * **思路**：树的直径是任意两个节点间路径的最大长度。这条路径可能穿过根节点，也可能完全包含在左子树或右子树中。对于任意一个节点，穿过它的最长路径是 `左子树深度 + 右子树深度`。我们需要一个全局变量来记录遍历过程中遇到的最大直径。
  * **代码示例**：

<!-- end list -->

```cpp
int diameter = 0;

// 函数返回从该节点向下的最大深度
int depthForDiameter(TreeNode* root) {
    if (root == nullptr) {
        return 0;
    }
    int left_depth = depthForDiameter(root->left);
    int right_depth = depthForDiameter(root->right);

    // 后序位置：计算穿过当前节点的最大路径长度，并更新全局变量
    diameter = std::max(diameter, left_depth + right_depth);

    // 返回当前节点的深度
    return std::max(left_depth, right_depth) + 1;
}

int diameterOfBinaryTree(TreeNode* root) {
    diameter = 0; // 重置全局变量
    depthForDiameter(root);
    return diameter;
}
```

### 类别二：树的修改与构造

这类问题要求你改变树的结构，或者根据给定的信息从零开始构建一棵树。

#### 1\. 翻转二叉树

  * **思路**：对于每个节点，交换它的左右子节点，然后递归地对它的左右子树进行翻转。这可以用前序或后序遍历的思路来解决。
  * **代码示例** (前序思路)：

<!-- end list -->

```cpp
TreeNode* invertTree(TreeNode* root) {
    if (root == nullptr) {
        return nullptr;
    }
    // 前序位置：交换当前节点的左右子节点
    TreeNode* temp = root->left;
    root->left = root->right;
    root->right = temp;

    // 递归翻转左右子树
    invertTree(root->left);
    invertTree(root->right);

    return root;
}
```

#### 2\. 根据前序和中序遍历结果构造二叉树

  * **思路**：这是构造类问题的经典。
    1.  前序遍历的第一个元素永远是当前（子）树的根节点。
    2.  在中序遍历中找到这个根节点，它左边的所有元素都属于左子树，右边的所有元素都属于右子树。
    3.  根据左、右子树的元素数量，可以在前序遍历中确定左右子树的范围。
    4.  递归地为左右子树构造。
  * **代码示例** (使用哈希表优化查找速度)：

<!-- end list -->

```cpp
TreeNode* buildTreeHelper(const std::vector<int>& preorder, int pre_start, int pre_end,
                          const std::vector<int>& inorder, int in_start, int in_end,
                          std::unordered_map<int, int>& in_map) {
    if (pre_start > pre_end || in_start > in_end) {
        return nullptr;
    }

    int root_val = preorder[pre_start];
    TreeNode* root = new TreeNode(root_val);
    
    int in_root_idx = in_map[root_val];
    int left_subtree_size = in_root_idx - in_start;

    root->left = buildTreeHelper(preorder, pre_start + 1, pre_start + left_subtree_size,
                                 inorder, in_start, in_root_idx - 1,
                                 in_map);
    root->right = buildTreeHelper(preorder, pre_start + left_subtree_size + 1, pre_end,
                                  inorder, in_root_idx + 1, in_end,
                                  in_map);
    return root;
}


TreeNode* buildTree(std::vector<int>& preorder, std::vector<int>& inorder) {
    std::unordered_map<int, int> in_map;
    for (int i = 0; i < inorder.size(); ++i) {
        in_map[inorder[i]] = i;
    }
    return buildTreeHelper(preorder, 0, preorder.size() - 1,
                         inorder, 0, inorder.size() - 1,
                         in_map);
}
```

### 类别三：特定路径与节点查找

这类问题通常涉及从根到叶子的路径，或者寻找满足特定条件的节点。

#### 1\. 路径总和

  * **思路**：判断是否存在一条从根到叶子的路径，使得路径上节点值的总和等于目标值 `targetSum`。我们可以用一个递归函数，传入当前节点和剩余需要凑的 `sum`。
  * **代码示例**：

<!-- end list -->

```cpp
bool hasPathSum(TreeNode* root, int targetSum) {
    if (root == nullptr) {
        return false;
    }
    // 到达叶子节点，并且路径和正好满足
    if (root->left == nullptr && root->right == nullptr && targetSum == root->val) {
        return true;
    }
    // 递归地在左右子树中查找
    // targetSum 减去当前节点的值
    return hasPathSum(root->left, targetSum - root->val) || 
           hasPathSum(root->right, targetSum - root->val);
}
```

#### 2\. 寻找最近公共祖先 (LCA)

  * **思路**：给定两个节点 `p` 和 `q`，寻找它们在树中的最近公共祖先。
    1.  如果当前节点 `root` 是 `p` 或 `q`，那么 `root` 就是LCA。
    2.  否则，递归地在左右子树中查找 `p` 和 `q`。
    3.  如果左右子树分别返回了 `p` 和 `q` 的查找结果（即一个在左，一个在右），那么当前节点 `root` 就是LCA。
    4.  如果只有一个子树返回了非空结果，说明 `p` 和 `q` 都在那个子树里，LCA也在那个子树里，向上返回那个结果。
  * **代码示例**：

<!-- end list -->

```cpp
TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
    if (root == nullptr || root == p || root == q) {
        return root;
    }
    
    TreeNode* left = lowestCommonAncestor(root->left, p, q);
    TreeNode* right = lowestCommonAncestor(root->right, p, q);
    
    if (left != nullptr && right != nullptr) {
        // p 和 q 分别在 root 的左右子树中
        return root;
    }
    
    // p 和 q 都在左子树或都在右子树中，或者只有一个存在
    return left != nullptr ? left : right;
}
```

### 类别四：二叉搜索树 (BST) 的特殊应用

二叉搜索树 (Binary Search Tree) 是一种特殊的二叉树，它要求任意节点的左子树所有节点值都小于它，右子树所有节点值都大于它。这个性质是解决BST问题的钥匙。

#### 1\. 验证是否为二叉搜索树

  * **思路1**：利用中序遍历。对BST进行中序遍历，得到的结果必须是一个严格递增的序列。
  * **思路2**：递归判断。对每个节点，限定它的取值范围 `(min, max)`。对于根节点，范围是 `(-inf, +inf)`。对于它的左子节点，范围变为 `(min, root.val)`；右子节点范围变为 `(root.val, max)`。
  * **代码示例** (思路2，更高效)：

<!-- end list -->

```cpp
bool isValidBSTHelper(TreeNode* root, TreeNode* minNode, TreeNode* maxNode) {
    if (root == nullptr) {
        return true;
    }
    if ((minNode != nullptr && root->val <= minNode->val) || 
        (maxNode != nullptr && root->val >= maxNode->val)) {
        return false;
    }
    return isValidBSTHelper(root->left, minNode, root) && 
           isValidBSTHelper(root->right, root, maxNode);
}

bool isValidBST(TreeNode* root) {
    return isValidBSTHelper(root, nullptr, nullptr);
}
```

#### 2\. 在BST中查找第K小的元素

  * **思路**：利用BST中序遍历结果为有序序列的特性。直接对BST进行中序遍历，并用一个计数器记录，当访问到第K个节点时，即为所求。
  * **代码示例**：

<!-- end list -->

```cpp
int kthSmallest(TreeNode* root, int k) {
    std::stack<TreeNode*> s;
    TreeNode* curr = root;
    while (curr != nullptr || !s.empty()) {
        while (curr != nullptr) {
            s.push(curr);
            curr = curr->left;
        }
        curr = s.top();
        s.pop();
        if (--k == 0) {
            return curr->val;
        }
        curr = curr->right;
    }
    return -1; // Should not happen if k is valid
}
```

-----

## 四、 总结与应试策略

1.  **烂熟于心四种遍历**：这是基础，递归和迭代版本都要能信手拈来。尤其是迭代版本，更能体现你的基本功。
2.  **优先思考递归**：拿到一个二叉树问题，首先思考“这个问题能否通过其左右子树的相同问题的解来得到？”如果可以，递归就是最自然的选择。定义好递归函数的**含义**（它做什么？返回什么？）和**基线条件** (Base Case)。
3.  **判断遍历顺序**：
      * 需要“自底向上”传递信息（如高度、子树节点数、是否平衡等） -\> **后序遍历**。
      * 需要“自顶向下”处理（如路径查找、翻转） -\> **前序遍历**。
      * 和有序性相关（尤其BST） -\> **中序遍历**。
      * 和“层”相关（如最短路径、按层打印） -\> **层序遍历 (BFS)**。
4.  **空间换时间**：在构造树或需要快速查找的问题中，果断使用 `unordered_map` (哈希表) 来缓存信息，将查找时间从 **O(N)** 降到 **O(1)**。
5.  **画图辅助**：在思考复杂问题（如LCA、构造树）时，不要干想。在纸上画一个简单的树形结构，模拟算法的执行过程，能极大地帮助你理清逻辑。
6.  **沟通与澄清**：面试中，可以向面试官确认节点的定义、树中是否包含重复值、节点值为null如何表示等问题。这能体现你的严谨性。

