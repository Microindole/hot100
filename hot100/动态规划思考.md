

动态规划的本质，是将一个复杂的大问题，拆解成一系列性质相同、规模更小的子问题。它与普通分治法（如归并排序）最大的不同在于，这些子问题之间往往是重叠的。

- **分治法**：子问题是相互独立的（如排序左半部分和右半部分）。
- **动态规划**：子问题是相互关联、相互重叠的（如计算第10个斐波那契数，需要先算第9个和第8个；而算第9个又需要第8个和第7个，你看，第8个就被重复计算了）。

为了避免重复计算这些重叠的子问题，动态规划采取的核心策略就是你说的：

1. **保存已知**：每当解决一个子问题后，就把它的解**存储起来**（通常用一个数组或哈希表，这个存储空间我们称之为“DP表”或“备忘录”）。
2. **推未知**：当需要解决一个更大的问题时，我们首先查看构成它的那些更小的子问题的解是否已经被计算过。如果已经算过了（即“已知”），就直接拿来用，而不再重新计算。通过这种方式，从最简单的子问题开始，一步步地**递推**，最终得到大问题的解。

这个过程，我们称之为“**状态转移**”。

------



### 动态规划的实现四部曲



解决一个动态规划问题，通常遵循以下四个明确的步骤。我们把它想象成填一张表格的过程。



#### 1. 定义状态 (Define the State)



这是最关键也是最难的一步。你需要定义一个 `dp` 数组（或矩阵），并明确 `dp[i]` 或 `dp[i][j]` 到底代表什么。这个状态的定义必须满足**无后效性**，即一旦某个状态的值确定了，它就不会再被后面的决策所改变。同时，它必须能包含解决后续问题所需的所有信息。

- **问自己**：`dp[i]` 代表的是什么？是数量、最大值、最小值，还是可能性？



#### 2. 找出状态转移方程 (Find the State Transition Equation)



这是动态规划的灵魂。你需要找到 `dp[i]` 与之前已经计算出的状态（如 `dp[i-1]`, `dp[i-2]` 等）之间的数学关系。这个方程描述了如何从“已知”推导出“未知”。

- **问自己**：如何通过一个或多个小规模子问题的解，计算出当前这个更大问题的解？`dp[i]` 应该如何由 `dp[... ]` 推导出来？



#### 3. 确定初始状态/边界条件 (Determine the Base Cases)



任何递推都需要一个起点。这个起点就是不需要依赖任何其他状态就能直接确定的值。这通常是 `dp[0]` 或 `dp[0][0]` 等。

- **问自己**：这个递推公式的终点在哪里？最小的子问题是什么，它的解能直接写出来吗？



#### 4. 确定计算顺序 (Determine the Calculation Order)



为了保证我们在计算 `dp[i]` 时，它所依赖的子问题 `dp[...]` 都已经被计算出来了，我们需要确定一个正确的遍历顺序。

- **问自己**：是应该从左到右，还是从右到左？是应该从上到下，还是从下到上？

------



### 举例

#### 示例1：斐波那契数列 (最简单的入门)



**问题**：求第 n 个斐波那契数 (F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2))。

1. **定义状态**：`dp[i]` 就表示第 `i` 个斐波那契数的值。
2. **状态转移方程**：`dp[i] = dp[i-1] + dp[i-2]`。你看，这就是用已知的 `dp[i-1]` 和 `dp[i-2]` 推未知的 `dp[i]`。
3. **初始状态**：`dp[0] = 0`, `dp[1] = 1`。这是递推的起点。
4. **计算顺序**：显然，我们应该从 `i=2` 开始，从小到大依次计算，直到 `n`。

```c++
int fib(int n) {
    if (n <= 1) return n;
    std::vector<int> dp(n + 1);
    dp[0] = 0;
    dp[1] = 1;
    for (int i = 2; i <= n; ++i) {
        dp[i] = dp[i-1] + dp[i-2]; // 状态转移
    }
    return dp[n];
}
```



#### 示例2：凑零钱问题 (经典DP)



问题：给你不同面额的硬币 coins 和一个总金额 amount。计算凑成总金额所需的最少的硬币个数。如果无法凑成，返回 -1。

(例如: coins = [1, 2, 5], amount = 11, 结果是 3，因为 5+5+1=11)

1. **定义状态**：`dp[i]` 表示凑成金额 `i` 所需的**最少**硬币个数。

2. 状态转移方程：对于金额 i，它可以由 i - coin_j 的金额再加一枚面值为 coin_j 的硬币凑成。因为我们要最少的硬币，所以要遍历所有可能的硬币 coin_j：

   dp[i] = min(dp[i - coin_j]) + 1 (对于所有 j 使得 i >= coin_j)

3. **初始状态**：`dp[0] = 0` (凑成金额0需要0个硬币)。为了方便求最小值，我们可以将 `dp` 数组的其他值初始化为一个极大值（比如 `amount + 1`）。

4. **计算顺序**：从 `i=1` 到 `amount` 依次计算。

```c++
int coinChange(std::vector<int>& coins, int amount) {
    std::vector<int> dp(amount + 1, amount + 1); // 初始化为最大值
    dp[0] = 0; // 初始状态

    for (int i = 1; i <= amount; ++i) { // 遍历所有金额
        for (int coin : coins) { // 遍历所有硬币
            if (i >= coin) {
                // 状态转移方程
                dp[i] = std::min(dp[i], dp[i - coin] + 1);
            }
        }
    }
    return dp[amount] > amount ? -1 : dp[amount];
}
```

------



### 什么题型一看就要用动态规划？



当你看到一个问题，感觉它有以下几个特征时，就要高度怀疑是动态规划：

1. **求最值问题**：

   - **最**长公共子序列、**最**长递增子序列...

   - **最**少硬币数、**最**小路径和...

   - 最大价值（背包问题）...

     这些问题要求你从众多可能性中找到一个最优解。DP 正是寻找最优解的强大工具。

2. **求方案总数问题**：

   - 机器人从左上角到右下角共有多少**种**走法...

   - 爬楼梯共有多少**种**方法...

   - 用 n 个括号可以组成多少种合法的组合...

     这类问题不是要最优解，而是要统计所有可行解的数量。DP 可以通过累加的方式计算出总数。

3. **求可行性问题**：

   - 能否用给定的硬币凑出某个金额...

   - 能否将一个字符串分割成字典中的单词...

     这类问题的答案通常是 true 或 false。dp 数组可以定义为布尔类型 dp[i]，表示“是否可行”。



#### 核心特征的检查：



- **重叠子问题 (Overlapping Subproblems)**：在用递归暴力求解时，你是否发现很多函数被重复调用了？例如 `fib(3)` 在计算 `fib(5)` 时被调用了两次。这是使用DP进行优化的最明显信号。
- **最优子结构 (Optimal Substructure)**：问题的最优解是否可以由其子问题的最优解构成？例如，凑成11元的最优解，必然包含了凑成 `11-coin` 元的某个最优解。如果满足这个性质，就可以放心地使用状态转移。



### 总结



- **核心思想**：将大问题分解为重叠的子问题，通过存储子问题的解（**备忘录/DP表**）来避免重复计算，从最简单的子问题出发，一步步递推到最终解。
- **方法论**：遵循**定义状态 -> 找转移方程 -> 定初始条件 -> 定计算顺序**的四步法。
- **题型识别**：重点关注求**最值**、**方案总数**和**可行性**的问题，并检查其是否具备**重叠子问题**和**最优子结构**的特征。

